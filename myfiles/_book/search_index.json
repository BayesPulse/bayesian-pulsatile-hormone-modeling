[
["index.html", "Bayesian Pulsatile Hormone Modeling with R Preface", " Bayesian Pulsatile Hormone Modeling with R Some subtitle Nichole E Carlson, Karen Liu, Matthew J Mulvahill, and Ken Horton 2018-02-21 Preface Hello world! "],
["introduction.html", "1 Introduction", " 1 Introduction "],
["development-plan.html", "2 Development Plan 2.1 Software map 2.2 Base code versions for github archiving", " 2 Development Plan Algorithm incorporation Joint pulses covariates Population model covariates Modularization/refactoring Manual/webbook Package features Summary and diagnostic functions 2.1 Software map Single subject Single hormone 2 hormones Options: Orderstat vs Strauss Changing baseline?? Population model Single hormone Single group (no covariates) Covariates (&gt; 1 group) Choose which parameters to do as a regression (- categorical parameters; - continuous parameters), others under single group assumptions. 2 hormones Single group non 1-to-1 (imperfect) 2 driver (method needed) (what does this mean?) Covariates (&gt; 1 group) non 1-to-1, imperfect, ???pamm done (p), need v/nu?? (what does this mean?) 2 driver (method needed) (what does this mean?) 2.2 Base code versions for github archiving All variations Major versions Single-subject, single hormone Single-subject, associational (2-hormone) Population model, single hormone Population model, covariates, single hormone Population model, associational (2-hormone) hormone Population model, covariates, associational (2-hormone) hormone Minor versions Fixed baseline vs. change-point baseline vs changing baseline (sinusoidal) Orderstat vs. Strauss prior on pulse location Log-normal vs. truncated t prior on mean mass/width Only truncated-t going forward Inverse Wishart vs. half-Cauchy vs. Uniform prior on re_sd Only Uniform prior going forward Questions Terminology: driver/response OR trigger/response Summary and diagnostic functions mcmc_trace &lt;- function() {} mcmc_posteriors &lt;- function() {} mcmc_locations &lt;- function() {} STAN and other Bayesian R package functions to implement Posterior predicted values/plot rstanarm::posterior_predict() rstanarm::ppc_dens_overlay() rstanarm::ppc_intervals() Posterior densities rstanarm::mcmc_areas() #-------------------------------------------- # STAN examples # Some examples http://mc-stan.org/bayesplot/ #-------------------------------------------- if (!require(bayesplot)) install.packages(&quot;bayesplot&quot;) if (!require(rstanarm)) install.packages(&quot;rstanarm&quot;) if (!require(ggplot2)) install.packages(&quot;ggplot2&quot;) library(bayesplot) library(rstanarm) library(ggplot2) fit &lt;- stan_glm(mpg ~ ., data = mtcars) ## ## SAMPLING FOR MODEL &#39;continuous&#39; NOW (CHAIN 1). ## ## Gradient evaluation took 2.8e-05 seconds ## 1000 transitions using 10 leapfrog steps per transition would take 0.28 seconds. ## Adjust your expectations accordingly! ## ## ## Iteration: 1 / 2000 [ 0%] (Warmup) ## Iteration: 200 / 2000 [ 10%] (Warmup) ## Iteration: 400 / 2000 [ 20%] (Warmup) ## Iteration: 600 / 2000 [ 30%] (Warmup) ## Iteration: 800 / 2000 [ 40%] (Warmup) ## Iteration: 1000 / 2000 [ 50%] (Warmup) ## Iteration: 1001 / 2000 [ 50%] (Sampling) ## Iteration: 1200 / 2000 [ 60%] (Sampling) ## Iteration: 1400 / 2000 [ 70%] (Sampling) ## Iteration: 1600 / 2000 [ 80%] (Sampling) ## Iteration: 1800 / 2000 [ 90%] (Sampling) ## Iteration: 2000 / 2000 [100%] (Sampling) ## ## Elapsed Time: 0.279802 seconds (Warm-up) ## 0.265879 seconds (Sampling) ## 0.545681 seconds (Total) ## ## ## SAMPLING FOR MODEL &#39;continuous&#39; NOW (CHAIN 2). ## ## Gradient evaluation took 1.4e-05 seconds ## 1000 transitions using 10 leapfrog steps per transition would take 0.14 seconds. ## Adjust your expectations accordingly! ## ## ## Iteration: 1 / 2000 [ 0%] (Warmup) ## Iteration: 200 / 2000 [ 10%] (Warmup) ## Iteration: 400 / 2000 [ 20%] (Warmup) ## Iteration: 600 / 2000 [ 30%] (Warmup) ## Iteration: 800 / 2000 [ 40%] (Warmup) ## Iteration: 1000 / 2000 [ 50%] (Warmup) ## Iteration: 1001 / 2000 [ 50%] (Sampling) ## Iteration: 1200 / 2000 [ 60%] (Sampling) ## Iteration: 1400 / 2000 [ 70%] (Sampling) ## Iteration: 1600 / 2000 [ 80%] (Sampling) ## Iteration: 1800 / 2000 [ 90%] (Sampling) ## Iteration: 2000 / 2000 [100%] (Sampling) ## ## Elapsed Time: 0.265821 seconds (Warm-up) ## 0.206396 seconds (Sampling) ## 0.472217 seconds (Total) ## ## ## SAMPLING FOR MODEL &#39;continuous&#39; NOW (CHAIN 3). ## ## Gradient evaluation took 1.2e-05 seconds ## 1000 transitions using 10 leapfrog steps per transition would take 0.12 seconds. ## Adjust your expectations accordingly! ## ## ## Iteration: 1 / 2000 [ 0%] (Warmup) ## Iteration: 200 / 2000 [ 10%] (Warmup) ## Iteration: 400 / 2000 [ 20%] (Warmup) ## Iteration: 600 / 2000 [ 30%] (Warmup) ## Iteration: 800 / 2000 [ 40%] (Warmup) ## Iteration: 1000 / 2000 [ 50%] (Warmup) ## Iteration: 1001 / 2000 [ 50%] (Sampling) ## Iteration: 1200 / 2000 [ 60%] (Sampling) ## Iteration: 1400 / 2000 [ 70%] (Sampling) ## Iteration: 1600 / 2000 [ 80%] (Sampling) ## Iteration: 1800 / 2000 [ 90%] (Sampling) ## Iteration: 2000 / 2000 [100%] (Sampling) ## ## Elapsed Time: 0.253383 seconds (Warm-up) ## 0.264594 seconds (Sampling) ## 0.517977 seconds (Total) ## ## ## SAMPLING FOR MODEL &#39;continuous&#39; NOW (CHAIN 4). ## ## Gradient evaluation took 1.2e-05 seconds ## 1000 transitions using 10 leapfrog steps per transition would take 0.12 seconds. ## Adjust your expectations accordingly! ## ## ## Iteration: 1 / 2000 [ 0%] (Warmup) ## Iteration: 200 / 2000 [ 10%] (Warmup) ## Iteration: 400 / 2000 [ 20%] (Warmup) ## Iteration: 600 / 2000 [ 30%] (Warmup) ## Iteration: 800 / 2000 [ 40%] (Warmup) ## Iteration: 1000 / 2000 [ 50%] (Warmup) ## Iteration: 1001 / 2000 [ 50%] (Sampling) ## Iteration: 1200 / 2000 [ 60%] (Sampling) ## Iteration: 1400 / 2000 [ 70%] (Sampling) ## Iteration: 1600 / 2000 [ 80%] (Sampling) ## Iteration: 1800 / 2000 [ 90%] (Sampling) ## Iteration: 2000 / 2000 [100%] (Sampling) ## ## Elapsed Time: 0.27601 seconds (Warm-up) ## 0.275927 seconds (Sampling) ## 0.551937 seconds (Total) posterior &lt;- as.matrix(fit) plot_title &lt;- ggtitle(&quot;Posterior distributions with medians and 80% intervals&quot;) mcmc_areas(posterior, pars = c(&quot;cyl&quot;, &quot;drat&quot;, &quot;am&quot;, &quot;wt&quot;), prob = 0.8) + plot_title ppc_intervals(y = mtcars$mpg, yrep = posterior_predict(fit), x = mtcars$wt, prob = 0.5) + labs(x = &quot;Weight (1000 lbs)&quot;, y = &quot;MPG&quot;, title = &quot;50% posterior predictive intervals \\nvs observed miles per gallon&quot;, subtitle = &quot;by vehicle weight&quot;) + panel_bg(fill = &quot;gray95&quot;, color = NA) + grid_lines(color = &quot;white&quot;) "],
["derivations-of-posterior-distributions.html", "3 Derivations of posterior distributions 3.1 Single-subject", " 3 Derivations of posterior distributions 3.1 Single-subject 3.1.1 \\(\\pi(\\nu|\\cdots)\\) – Standard deviation of the random effects $ \\[\\begin{align} \\pi(\\nu_{\\alpha} | \\cdots) &amp;\\propto \\pi(\\nu_{\\alpha}) \\pi(\\alpha_i | \\mu_{\\alpha}, \\nu_{\\alpha}, \\vect{\\kappa}_{\\alpha}) \\\\ where,\\\\ &amp; \\nu_{\\alpha} \\sim Unif(0, a)\\\\ &amp; \\alpha_i | \\mu_{\\alpha}, \\nu_{\\alpha}, \\vect{\\kappa}_{\\alpha} \\sim t^+_4 (\\mu_{\\alpha}, \\nu^2_{\\alpha})\\\\ \\\\ \\end{align}\\] $ The distribution of \\(\\nu_{\\alpha}\\) is evident. The distribution of \\(\\pi(\\alpha_i | \\mu_{\\alpha}, \\nu_{\\alpha}, \\vect{\\kappa}_{\\alpha})\\) is achieved using a normal-gamma mixture: $ \\[\\begin{align} \\pi(\\alpha_i | \\mu_{\\alpha}, \\nu_{\\alpha}, \\vect{\\kappa}_{\\alpha}) &amp;\\sim N^+ (\\mu_{\\alpha}, \\frac{\\nu^2_{\\alpha}}{\\vect{\\kappa}_{\\alpha}})\\\\ where,\\\\ &amp; \\vect{\\kappa}_{\\alpha} \\sim \\Gamma(r/2,r/2)\\\\ \\end{align}\\] $ "]
]
